#ifndef DLCALC_H#define DLCALC_H#ifdef __cplusplusextern "C" {#endif	enum {		DK_EX,		DK_MU,		DK_MC,		DK_MR,		DK_M_MINUS,		DK_M_PLUS,		DK_GT,		DK_BS,		DK_PERC,		DK_SQRT,		DK_SIGN,		DK_MULT,		DK_DIV,		DK_CE,		DK_PLUS,		DK_MINUS,		DK_AC,		DK_EQU,		DK_PERIOD,		DK_00,		DK_0,		DK_1,		DK_2,		DK_3,		DK_4,		DK_5,		DK_6,		DK_7,		DK_8,		DK_9,		DK_OFF	};	enum {		DS_INPUT,		DS_INPUT_DECIMAL,		DS_INPUT_NOSWAP,		DS_INPUT_DECIMAL_NOSWAP,		DS_BINOP,		DS_RESULT_WEAK, // Weak result is usually for the 1st / 2nd parameter during input. It is gen. by MR, sqrt, GT, etc.		DS_RESULT_WEAK_NOSWAP,		DS_RESULT_STRONG, // Strong result is made from M+/M-/=/etc. and cannot be used as the 2nd arg of % / MU / etc., but can do multiple EQU's.		// However since M+/M- clears arg1, they essentially cannot do multiple EQU's.		DS_RESULT_GT_WEAK, // Special type of weak result. On this state, another press on GT will clear the GT memory.		DS_RESULT_GT_WEAK_NOSWAP,		DS_RESULT_GT_STRONG,		DS_RESULT_MU, // Special type of strong result. On this state, another press on MU when bin=DIV will reveal DIVTWICE result.		DS_ERROR, // Common error status. A backspace, CE, AC, etc. can exit from this error status.		DS_ERROR_GT, // A stricter error when GT overflows. Only CE / AC can exit this error status. In this state GT on screen should blink.		DS_ERROR_M, // Similar to DS_ERROR_GT. 		DS_ERROR_INPUT, // Error when attempting to input 13th digit. When bksp is pressed it is reverted to DS_INPUT rather than DS_RESULT_STRONG.		DS_ERROR_INPUT_NOSWAP	};	enum {		DM_CEIL,		DM_ROUND,		DM_FLOOR	};	enum {		DF_ADD2,		DF_4,		DF_3,		DF_2,		DF_0,		DF_F	};	enum {		DL_SEG_0 = 1,		DL_SEG_1 = 2,		DL_SEG_2 = 4,		DL_SEG_3 = 8,		DL_SEG_4 = 16,		DL_SEG_5 = 32,		DL_SEG_6 = 64,		DL_SEG_PERIOD = 128,		DL_GT = 1,		DL_M = 2,		DL_MINUS = 4,		DL_E = 8	};	enum {		DB_NONE,		DB_PLUS,		DB_MINUS,		DB_MULT,		DB_DIV,		DB_DIV_TWICE // For MU only	};	/*		A digit lcd (8.) is represented with a byte.		The bit order is shown below.			000000		   1      2		   1      2		    333333		   4      5		   4      5		    666666   77	*/	typedef struct dlcalc_lcd {		unsigned char digits[12]; // [0] would be the rightmost		unsigned char specials;		unsigned short commas;	} DLLCD;	typedef struct dlcalc_number {		unsigned char digits[12]; // [0] would be the lowest; 0x30 to 0x39		int minus_mark;		int period_pos;	} DLNumber;	typedef struct dlcalc_record {		int power;		int roundMode;		int fixMode;		int currentBinary;		int state;		DLNumber arg1;		DLNumber buffer;		DLNumber gt;		DLNumber mem;		DLLCD lcd;	} DLCalc;	DLCalc *DLNew();	void DLReset(DLCalc *calc);	void DLInitializeNumber(DLNumber *num);	void DLTrimNumber(DLNumber *num);	int DLAdd(DLNumber *a, DLNumber *b, DLNumber *dest);	int DLSub(DLNumber *a, DLNumber *b, DLNumber *dest);	int DLMul(DLNumber *a, DLNumber *b, DLNumber *dest);	int DLDiv(DLNumber *a, DLNumber *b, DLNumber *dest);	int DLPerc(int op, DLNumber *a, DLNumber *b, DLNumber *dest);	int DLMU(int op, DLNumber *a, DLNumber *b, DLNumber *dest);	int DLSqrt(DLNumber *x, DLNumber *dest);	int DLIsZero(DLNumber *x);	void DLRound(DLCalc *calc, DLNumber *x);	void DLLCDRender(DLCalc *calc, unsigned char timer);	void DLLCDClear(DLCalc *calc);	void DLFormatDLNumber(const DLNumber *n, char *target);	void DLOPPushButton(DLCalc *calc, int btn);	void DLOPSetRoundMode(DLCalc *calc, int mode);	void DLOPSetFixMode(DLCalc *calc, int mode);	void DLShiftOut(DLNumber *n);	int DLShiftIn(DLNumber *n, char fill, int shiftDot);	int DLDoOp(DLNumber *a, DLNumber *b, int op, DLNumber *dst);#ifdef __cplusplus};#endif#endif /* DLCALC_H */
#include "dlcalc.h"#include <stdlib.h>#include <string.h>#include "mini-gmp.h"void format_into_fixed(DLNumber *n, char *dst);int AppError(char *msg, ...);/*		A digit lcd (8.) is represented with a byte.		The bit order is shown below.			000000		   1      2		   1      2		    333333		   4      5		   4      5		    666666   77	*/const unsigned char lcd_glyph[] = {0x77, 0x24, 0x5D, 0x6D, 0x2E, 0x6B, 0x7B, 0x27, 0x7F, 0x6F};DLCalc *DLNew() {	DLCalc *c = (DLCalc *)malloc(sizeof(DLCalc));	if (!c) return NULL;	DLReset(c);	return c;}void DLReset(DLCalc *calc) {	calc->power = 1;	calc->fixMode = DF_F;	calc->roundMode = DM_FLOOR;	calc->currentBinary = DB_NONE;	calc->state = DS_RESULT_STRONG;	DLInitializeNumber(&calc->arg1);	DLInitializeNumber(&calc->buffer);	DLInitializeNumber(&calc->gt);	DLInitializeNumber(&calc->mem);	DLLCDRender(calc,0);}void DLInitializeNumber(DLNumber *num) {	memset(num,0,sizeof(DLNumber));	num->digits[0] = '0';}int DLIsZero(DLNumber *x) {	int i;	for (i = 0; i < 12; i++) {		if (x->digits[i] != 0 && x->digits[i] != '0')			return 0;	}	return 1;}void DLTrimNumber(DLNumber *num) {	int i,j;	if (DLIsZero(num)) {		DLInitializeNumber(num);		return;	}	if (num->period_pos == 0) return;	for (i=0; i<num->period_pos; i++) {		if (num->digits[i] != '0') {			break;		}	}	if (i==0) return;	for (j=0; j<12-i; j++) {		num->digits[j] = num->digits[j+i];	}	for (j = 12-i; j < 12; j++) {		num->digits[j] = 0;	}	num->period_pos -= i;}/*	e.g.	0.3375 => 337500000000			332.44 => 332440000000000	This is to send it to bn.c for arithmetic calculation.*/void format_into_fixed(DLNumber *n, char *dst) {	int highest_non_zero;	int padding_zeroes = 12 - n->period_pos;	char *ptr;	for (highest_non_zero = 11; highest_non_zero >= 0; highest_non_zero--) {		if (n->digits[highest_non_zero] != 0 && n->digits[highest_non_zero] != '0')			break;	}	if (highest_non_zero < 0) {		strcpy(dst,"0");		return;	}	ptr = dst;	if (n->minus_mark) *(ptr++) = '-';	while (highest_non_zero >= 0) {		if (n->digits[highest_non_zero])			*ptr = n->digits[highest_non_zero];		else			*ptr = '0';		ptr++;		highest_non_zero--;	}	while (padding_zeroes) {		*ptr = '0';		ptr++;		padding_zeroes--;	}	*ptr = 0;	return;}// 0: Success// 1: Overflow (FIXED > 24)// Either will change target. Sadly this does not behave exactly like DL-1654.// Notice that we will not do rounding here. This is what DL-1654 actually behaves.int fixed_to_dl(char *str, DLNumber *target) {	int len = strlen(str);	if (str == NULL || !strcmp(str,"0")) {		DLInitializeNumber(target);		return 0;	}	if (len <= 12) {		// less than 1. we need to append 0. prefix so we can only pick the first 11 digits.		int padding_zeroes = 13 - len;		int i = len - 2, flg = 0;		while (i >= 0) {			target->digits[flg] = str[i];			flg++; i--;		}		while (padding_zeroes > 0) {			target->digits[flg] = '0';			flg++;			padding_zeroes--;		}		target->period_pos = 11;	} else {		// Pick as many as possible since we cannot retain the full 12-digit decimals anyway.		int i = 11, flg = 0;		while (i >= 0) {			target->digits[flg] = str[i];			flg++; i--;		}		target->period_pos = 24 - len;	}	if (target->period_pos < 0) {		while (target->period_pos < 0)			target->period_pos = target->period_pos + 12;		return 1;	}	DLTrimNumber(target);	return 0;}void DLFormatDLNumber(const DLNumber *n, char *target) {	char *ptr = target;	int i;	if (n->minus_mark) *(ptr++) = '-';	for (i = 11; i >= 0; i--) {		if (n->digits[i] != 0) {			*(ptr++) = n->digits[i];			if (n->period_pos == i)				*(ptr++) = '.';		}	}	*(ptr++) = '\0';}int DLAdd(DLNumber *a, DLNumber *b, DLNumber *dest) {	int status = 0;	int result;	char a_str[64];	char b_str[64];	char c_str[64];	mpz_t na, nb, nc;	mpz_init(na);	mpz_init(nb);	mpz_init(nc);	format_into_fixed(a,a_str);	format_into_fixed(b,b_str);	mpz_set_str(na,a_str,10);	mpz_set_str(nb,b_str,10);	mpz_add(nc,na,nb);	mpz_get_str(c_str,10,nc);	if (c_str[0] == '-') {		status = fixed_to_dl(c_str+1,dest);		dest->minus_mark = 1;	} else {		status = fixed_to_dl(c_str,dest);		dest->minus_mark = 0;	}		mpz_clear(na);	mpz_clear(nb);	mpz_clear(nc);	return status;}int DLSub(DLNumber *a, DLNumber *b, DLNumber *dest) {	int status = 0;	int result;	char a_str[64];	char b_str[64];	char c_str[64];	mpz_t na, nb, nc;	mpz_init(na);	mpz_init(nb);	mpz_init(nc);		format_into_fixed(a,a_str);	format_into_fixed(b,b_str);	mpz_set_str(na,a_str,10);	mpz_set_str(nb,b_str,10);	mpz_sub(nc,na,nb);	mpz_get_str(c_str,10,nc);	if (c_str[0] == '-') {		status = fixed_to_dl(c_str+1,dest);		dest->minus_mark = 1;	} else {		status = fixed_to_dl(c_str,dest);		dest->minus_mark = 0;	}		mpz_clear(na);	mpz_clear(nb);	mpz_clear(nc);	return status;}int DLMul(DLNumber *a, DLNumber *b, DLNumber *dest) {	int status = 0;	int result;	char a_str[64];	char b_str[64];	char c_str[64];	mpz_t na, nb, nc, nd, nOffset;	mpz_init(na);	mpz_init(nb);	mpz_init(nc);	mpz_init(nd);	mpz_init(nOffset);	format_into_fixed(a,a_str);	format_into_fixed(b,b_str);	mpz_set_str(na,a_str,10);	mpz_set_str(nb,b_str,10);	mpz_set_str(nOffset,"1000000000000",10);	mpz_mul(nc,na,nb);	mpz_cdiv_q(nd,nc,nOffset);	mpz_get_str(c_str,10,nd);	if (c_str[0] == '-') {		status = fixed_to_dl(c_str+1,dest);		dest->minus_mark = 1;	} else {		status = fixed_to_dl(c_str,dest);		dest->minus_mark = 0;	}	mpz_clear(na);	mpz_clear(nb);	mpz_clear(nc);	mpz_clear(nd);	mpz_clear(nOffset);	return status;}int DLDiv(DLNumber *a, DLNumber *b, DLNumber *dest) {	int status = 0;	int result;	char a_str[64];	char b_str[64];	char c_str[64];	mpz_t na, nb, nc, nd, nOffset;	if (DLIsZero(b)) {		DLInitializeNumber(dest);		return 1;	}	mpz_init(na);	mpz_init(nb);	mpz_init(nc);	mpz_init(nd);	mpz_init(nOffset);	format_into_fixed(a,a_str);	format_into_fixed(b,b_str);	mpz_set_str(na,a_str,10);	mpz_set_str(nb,b_str,10);	mpz_set_str(nOffset,"1000000000000",10);	mpz_mul(nc,na,nOffset);	mpz_cdiv_q(nd,nc,nb);	mpz_get_str(c_str,10,nd);	if (c_str[0] == '-') {		status = fixed_to_dl(c_str+1,dest);		dest->minus_mark = 1;	} else {		status = fixed_to_dl(c_str,dest);		dest->minus_mark = 0;	}	mpz_clear(na);	mpz_clear(nb);	mpz_clear(nc);	mpz_clear(nd);	mpz_clear(nOffset);	return status;}int DLPerc(int op, DLNumber *a, DLNumber *b, DLNumber *dest) {	DLNumber oneHundred, bRatio, tmp1, tmp2, aAbs;	int status = 0;	aAbs = *a; aAbs.minus_mark = 0; oneHundred.minus_mark = 0; tmp1.minus_mark = 0; tmp2.minus_mark = 0; aAbs.minus_mark = 0;	fixed_to_dl("100000000000000",&oneHundred);	DLDiv(b,&oneHundred,&bRatio);	switch (op) {	case DB_PLUS:		DLInitializeNumber(dest);		DLMul(&aAbs,&bRatio,&tmp1);		status = DLAdd(&tmp1,&aAbs,&tmp2);		break;	case DB_MINUS:		DLInitializeNumber(dest);		DLMul(&aAbs,&bRatio,&tmp1);		status = DLSub(&aAbs,&tmp1,&tmp2);		break;	case DB_MULT:		status = DLMul(&aAbs,b,&tmp1);		if (status) {			tmp2 = tmp1;			break;		}		DLDiv(&tmp1,&oneHundred,&tmp2);		break;	case DB_DIV:		status = DLDiv(&aAbs,b,&tmp1);		if (status) {			tmp2 = tmp1;			break;		}		status = DLMul(&tmp1,&oneHundred,&tmp2);		break;	default:		tmp2 = *a;		break;	}	if (a->minus_mark)			tmp2.minus_mark = !tmp2.minus_mark;	if (status) {		DLInitializeNumber(dest);	} else {		*dest = tmp2;	}	return status;}int DLMU(int op, DLNumber *a, DLNumber *b, DLNumber *dest) {	DLNumber oneHundred, tmp1, tmp2, tmp3, tmp4, res;	int status;	oneHundred.minus_mark = 0;	tmp1.minus_mark = 0; tmp2.minus_mark = 0; tmp3.minus_mark = 0; tmp4.minus_mark = 0;	res.minus_mark = 0;	fixed_to_dl("100000000000000",&oneHundred);	DLInitializeNumber(dest);	switch (op) {	case DB_PLUS:		status = DLMul(a,&oneHundred,&tmp1);		if (status) return 1;		status = DLDiv(&tmp1,b,&tmp2);		if (status) return 1;		status = DLAdd(&tmp2,&oneHundred,&res);		if (status) return 1;		break;	case DB_MINUS:		status = DLSub(a,b,&tmp1);		if (status) return 1;		status = DLMul(&tmp1,&oneHundred,&tmp2);		if (status) return 1;		status = DLDiv(&tmp2,b,&res);		if (status) return 1;		break;	case DB_MULT:		return DLPerc(DB_PLUS,a,b,dest);		break;	case DB_DIV:		status = DLSub(&oneHundred,b,&tmp1);		if (status) return 1;		status = DLDiv(&tmp1,&oneHundred,&tmp2);		if (status) return 1;		status = DLDiv(a,&tmp2,&res);		if (status) return 1;		break;	case DB_DIV_TWICE:		status = DLSub(&oneHundred,b,&tmp1);		if (status) return 1;		status = DLDiv(&tmp1,&oneHundred,&tmp2);		if (status) return 1;		status = DLDiv(a,&tmp2,&tmp3);		if (status) return 1;		status = DLSub(&tmp3,a,&res);		if (status) return 1;		res.minus_mark = 0;		break;	}	*dest = res;	return 0;}int DLSqrt(DLNumber *x, DLNumber *dest) {	int status;	int result;	char a_str[64];	char b_str[64];	char *ptr;	mpz_t i1, i2, i3, i4;	mpz_init(i1);	mpz_init(i2);	mpz_init(i3);	mpz_init(i4);	status = 0;	format_into_fixed(x,a_str);	if (x->minus_mark) {		status = 1;		ptr = a_str + 1;		dest->minus_mark = 1;	} else {		ptr = a_str;		dest->minus_mark = 0;	}	mpz_set_str(i1,ptr,10);	mpz_set_str(i2,"1000000000000",10);	mpz_mul(i3,i1,i2);	mpz_sqrt(i4,i3);	mpz_get_str(b_str,10,i4);	fixed_to_dl(b_str,dest);	mpz_clear(i1);	mpz_clear(i2);	mpz_clear(i3);	mpz_clear(i4);	return status;}int DLDoOp(DLNumber *a, DLNumber *b, int op, DLNumber *dst) {	DLNumber ta = *a;	DLNumber tb = *b;	switch (op) {	case DB_PLUS:		return DLAdd(&ta,&tb,dst);		break;	case DB_MINUS:		return DLSub(&ta,&tb,dst);		break;	case DB_MULT:		return DLMul(&ta,&tb,dst);		break;	case DB_DIV:		return DLDiv(&ta,&tb,dst);		break;	default:		AppError("Unexpected operation for DLDoOp: %d.\n",op);		return 1;		break;	}}void DLLCDRender(DLCalc *calc, unsigned char timer) {	int i;	DLLCDClear(calc);	// Render buffer	// digits	for (i=0; i<12; i++) {		int b = calc->buffer.digits[i];		if (b >= '0' && b <= '9') {			calc->lcd.digits[i] = lcd_glyph[b-'0'];		}	}	// apo's & dot	calc->lcd.commas = 0;	if (calc->buffer.period_pos >= 0 && calc->buffer.period_pos < 12) {		int s = calc->buffer.period_pos;		for (i = s; i<12; i++) {			if (calc->buffer.digits[i] < '0') break;			if (i-s > 0 && ((i-s) % 3 == 0)) {				calc->lcd.commas |= (1<<i);			}		}		calc->lcd.digits[calc->buffer.period_pos] |= 0x80;	}	// minus mark	if (calc->buffer.minus_mark) {		for (i=0; i<12; i++) {			if (calc->lcd.digits[i] == 0) {				calc->lcd.digits[i] = 0x08;				break;			}		}		if (i == 12) {			calc->lcd.specials |= DL_MINUS;		}	}	// GT	if (!DLIsZero(&calc->gt)) {		calc->lcd.specials |= DL_GT;	}	// M	if (!DLIsZero(&calc->mem)) {		calc->lcd.specials |= DL_M;	}	// E	if (calc->state == DS_ERROR || calc->state == DS_ERROR_GT || calc->state == DS_ERROR_INPUT || calc->state == DS_ERROR_INPUT_NOSWAP || calc->state == DS_ERROR_M) {		calc->lcd.specials |= DL_E;		if (calc->state == DS_ERROR_M) {			if (timer < 128) {				calc->lcd.specials &= ~DL_M;			} else {				calc->lcd.specials |= DL_M;			}		}		if (calc->state == DS_ERROR_GT) {			if (timer < 128) {				calc->lcd.specials &= ~DL_GT;			} else {				calc->lcd.specials |= DL_GT;			}		}	}}void DLLCDClear(DLCalc *calc) {	memset(&calc->lcd,0,sizeof(DLLCD));}void dl_reshape_number(DLCalc *calc, DLNumber *num) {	DLNumber tmp;	DLNumber oneHundred; oneHundred.minus_mark = 0;	switch (calc->fixMode) {	case DF_0: case DF_2: case DF_3: case DF_4:		DLRound(calc,num);		break;	case DF_F:		DLTrimNumber(num);		break;	}}/* Button Functions */void DLBtnXchg(DLCalc *calc, int prev_state, int *next_state) {	DLNumber tmp;	int tmp_result;	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP) return;	tmp = calc->buffer;	calc->buffer = calc->arg1;	calc->arg1 = tmp;	if (prev_state == DS_INPUT || prev_state == DS_INPUT_DECIMAL || prev_state == DS_RESULT_GT_WEAK || prev_state == DS_RESULT_WEAK) {		*next_state = DS_RESULT_WEAK;	} else if (prev_state == DS_INPUT_NOSWAP || prev_state == DS_INPUT_DECIMAL_NOSWAP || prev_state == DS_RESULT_WEAK_NOSWAP || prev_state == DS_RESULT_GT_WEAK_NOSWAP) {		*next_state = DS_RESULT_WEAK_NOSWAP;	} else if (prev_state == DS_RESULT_STRONG || prev_state == DS_RESULT_GT_STRONG || prev_state == DS_RESULT_MU) {		*next_state = DS_RESULT_STRONG;	} else if (prev_state == DS_BINOP) {		*next_state = DS_BINOP; // This is how DL-1654 behaves like.	} else {		AppError("[EX BUTTON] I don't know how to switch from state %d.\n",prev_state);		*next_state = DS_ERROR;	}}int DLAuxEval(DLCalc *calc) {	DLNumber tmp;	int tmp_result;	if (calc->state == DS_BINOP) {		if (calc->currentBinary == DB_MULT) {			calc->arg1 = calc->buffer; // ^2			DLTrimNumber(&calc->arg1);		} else if (calc->currentBinary == DB_DIV) {			fixed_to_dl("1000000000000",&calc->arg1);		}	}	if (calc->currentBinary == DB_NONE) {		tmp = calc->arg1;		if (calc->fixMode == DF_ADD2) {			DLNumber oneHundred = {0};			fixed_to_dl("10000000000",&oneHundred);			DLMul(&calc->arg1,&oneHundred,&tmp);		}		DLRound(calc,&tmp);		calc->buffer = tmp;	} else {		DLNumber tmp2;		DLTrimNumber(&calc->arg1);		if (calc->fixMode == DF_ADD2 && (calc->state == DS_INPUT_NOSWAP || calc->state == DS_INPUT) && (calc->currentBinary == DB_PLUS || calc->currentBinary == DB_MINUS)) {			DLNumber oneHundred = {0};			fixed_to_dl("10000000000",&oneHundred);			if (calc->state == DS_INPUT)				DLMul(&calc->buffer,&oneHundred,&tmp);			else {				tmp = calc->buffer;				DLMul(&calc->arg1,&oneHundred,&tmp2);				calc->arg1 = tmp2;			}		} else {			tmp = calc->buffer;		}		// calc->arg1 = calc->buffer;		tmp_result = DLDoOp(&calc->arg1,&tmp,calc->currentBinary,&tmp2);		// No need to swap args here!		calc->buffer = tmp2;		if (tmp_result) {			return 1;		}	}	return 0;}int DLAuxPercMult(DLNumber *a, DLNumber *b, DLNumber *dest) {	DLNumber oneOnOneHundred = {0};	DLNumber tmp1, tmp2;	int result;	fixed_to_dl("10000000000",&oneOnOneHundred);	if (DLMul(a,&oneOnOneHundred,&tmp1)) return 1;	if (DLMul(&tmp1,b,&tmp2)) return 1;	*dest = tmp2;	return 0;}int DLAuxPercDiv(DLNumber *a, DLNumber *b, DLNumber *dest) {	char buf[100];	DLNumber oneOnOneHundred = {0};	DLNumber tmp1, tmp2;	mpz_t na, nb, n_100;	int result;	mpz_init(na);	mpz_init(nb);	mpz_init(n_100);	mpz_set_str(n_100,"100000000000000",10);	format_into_fixed(a,buf);	mpz_set_str(na,buf,10);	format_into_fixed(b,buf);	mpz_set_str(nb,buf,10);	mpz_mul(na,na,n_100);	mpz_cdiv_q(na,na,nb);	mpz_get_str(buf,10,na);	if (buf[0] == '-') {		result = fixed_to_dl(buf+1,&tmp1);		tmp1.minus_mark = 1;	} else {		fixed_to_dl(buf,&tmp1);		tmp1.minus_mark = 0;	}	if (!result) *dest = tmp1;	mpz_clear(na);	mpz_clear(nb);	mpz_clear(n_100);	return result;}void DLBtnMu(DLCalc *calc, int prev_state, int *next_state) {	int tmp_result;	DLNumber tmp;	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP) return;	if (prev_state == DS_INPUT || prev_state == DS_INPUT_DECIMAL || prev_state == DS_RESULT_WEAK || prev_state == DS_RESULT_GT_WEAK) {		// Use buffer as the second arg.		if (calc->currentBinary == DB_NONE) return;		tmp_result = DLMU(calc->currentBinary,&calc->arg1,&calc->buffer,&tmp);		calc->buffer = tmp;		if (tmp_result) {			*next_state = DS_ERROR;		} else {			DLRound(calc,&calc->buffer);			*next_state = DS_RESULT_MU;		}		if (calc->currentBinary != DB_DIV) {			DLInitializeNumber(&calc->arg1);			calc->currentBinary = DB_NONE;		}	} else if (prev_state == DS_RESULT_MU && calc->currentBinary == DB_DIV) {		// Show the 2nd result of DIV MU		tmp_result = DLSub(&calc->buffer, &calc->arg1, &tmp);		calc->buffer = tmp;		if (tmp_result) {			*next_state = DS_ERROR;		} else {			DLRound(calc,&calc->buffer);			*next_state = DS_RESULT_MU;		}		DLInitializeNumber(&calc->arg1);		calc->currentBinary = DB_NONE;	} else {		// Do nothing	}}void DLBtnMc(DLCalc *calc, int prev_state, int *next_state) {	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP) return;	DLInitializeNumber(&calc->mem);}void DLBtnMr(DLCalc *calc, int prev_state, int *next_state) {	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP) return;	if (prev_state == DS_INPUT || prev_state == DS_INPUT_DECIMAL || prev_state == DS_RESULT_GT_WEAK || prev_state == DS_RESULT_WEAK) {		*next_state = DS_RESULT_WEAK;	} else if (prev_state == DS_INPUT_NOSWAP || prev_state == DS_INPUT_DECIMAL_NOSWAP || prev_state == DS_RESULT_WEAK_NOSWAP || prev_state == DS_RESULT_GT_WEAK_NOSWAP) {		*next_state = DS_RESULT_WEAK_NOSWAP;	} else if (prev_state == DS_RESULT_STRONG || prev_state == DS_RESULT_GT_STRONG || prev_state == DS_RESULT_MU) {		*next_state = DS_RESULT_WEAK_NOSWAP;	} else if (prev_state == DS_BINOP) {		calc->arg1 = calc->buffer;		*next_state = DS_RESULT_WEAK;	} else {		AppError("[MR BUTTON] I don't know how to switch from state %d.\n",prev_state);		*next_state = DS_ERROR;	}	calc->buffer = calc->mem;}void DLBtnMp(DLCalc *calc, int prev_state, int *next_state) {	int result = 0;	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP) return;	if (prev_state != DS_RESULT_STRONG && prev_state != DS_RESULT_GT_STRONG && prev_state != DS_RESULT_MU && prev_state != DS_INPUT_NOSWAP && prev_state != DS_INPUT_DECIMAL_NOSWAP &&	prev_state != DS_RESULT_WEAK_NOSWAP && prev_state != DS_RESULT_GT_WEAK_NOSWAP)		result = DLAuxEval(calc);	if (result) {		*next_state = DS_ERROR;	} else {		// The buffer here should be what to be added to mem		DLNumber res = calc->mem, tmp;		DLRound(calc,&calc->buffer);		result = DLAdd(&res,&calc->buffer,&tmp);		if (result) {			calc->buffer = tmp;			*next_state = DS_ERROR_M;		} else {			calc->mem = tmp;			*next_state = DS_RESULT_STRONG;		}	}}void DLBtnMm(DLCalc *calc, int prev_state, int *next_state) {	int result = 0;	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP) return;	if (prev_state != DS_RESULT_STRONG && prev_state != DS_RESULT_GT_STRONG && prev_state != DS_RESULT_MU) {		result = DLAuxEval(calc);	}	if (result) {		*next_state = DS_ERROR;	} else {		// The buffer here should be what to be added to mem		DLNumber res = calc->mem, tmp;		DLRound(calc,&calc->buffer);		result = DLSub(&res,&calc->buffer,&tmp);		if (result) {			calc->buffer = tmp;			*next_state = DS_ERROR_M;		} else {			calc->mem = tmp;			*next_state = DS_RESULT_STRONG;		}	}}void DLBtnGt(DLCalc *calc, int prev_state, int *next_state) {	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP) return;	if (prev_state == DS_INPUT || prev_state == DS_INPUT_DECIMAL || prev_state == DS_RESULT_GT_WEAK || prev_state == DS_RESULT_WEAK) {		*next_state = DS_RESULT_GT_WEAK;	} else if (prev_state == DS_INPUT_NOSWAP || prev_state == DS_INPUT_DECIMAL_NOSWAP || prev_state == DS_RESULT_WEAK_NOSWAP || prev_state == DS_RESULT_GT_WEAK_NOSWAP) {		*next_state = DS_RESULT_GT_WEAK_NOSWAP;	} else if (prev_state == DS_RESULT_STRONG || prev_state == DS_RESULT_GT_STRONG || prev_state == DS_RESULT_MU) {		*next_state = DS_RESULT_GT_WEAK_NOSWAP;	} else if (prev_state == DS_BINOP) {		calc->arg1 = calc->buffer;		*next_state = DS_RESULT_GT_WEAK;	} else {		AppError("[GT BUTTON] I don't know how to switch from state %d.\n",prev_state);		*next_state = DS_ERROR;	}	if (prev_state == DS_RESULT_GT_WEAK || prev_state == DS_RESULT_GT_WEAK_NOSWAP || prev_state == DS_RESULT_GT_STRONG) {		DLInitializeNumber(&calc->gt);	} else {		calc->buffer = calc->gt;	}}void DLBtnBs(DLCalc *calc, int prev_state, int *next_state) {	int dot = calc->buffer.period_pos;	// Error resolving	if (prev_state == DS_ERROR) {		*next_state = DS_RESULT_STRONG;		return;	} else if (prev_state == DS_ERROR_INPUT) {		*next_state = DS_INPUT;		return;	} else if (prev_state == DS_ERROR_INPUT_NOSWAP) {		*next_state = DS_INPUT_NOSWAP;		return;	}	// Shift out	DLShiftOut(&calc->buffer);	if (prev_state == DS_RESULT_GT_WEAK) {		*next_state = DS_RESULT_WEAK;	} else if (prev_state == DS_RESULT_GT_STRONG || prev_state == DS_RESULT_MU) {		*next_state = DS_RESULT_STRONG;	} else if (dot == 0) {		if (prev_state == DS_INPUT_DECIMAL) {			*next_state = DS_INPUT;		} else if (prev_state == DS_INPUT_DECIMAL_NOSWAP) {			*next_state = DS_INPUT_NOSWAP;		}	}}void DLBtnPc(DLCalc *calc, int prev_state, int *next_state) {	int tmp_result;	DLNumber tmp;	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP) return;	if (prev_state == DS_INPUT || prev_state == DS_INPUT_DECIMAL || prev_state == DS_INPUT_NOSWAP || prev_state == DS_INPUT_DECIMAL_NOSWAP || prev_state == DS_RESULT_WEAK || prev_state == DS_RESULT_GT_WEAK || prev_state == DS_RESULT_GT_WEAK_NOSWAP || prev_state == DS_RESULT_WEAK_NOSWAP) {		if (calc->currentBinary == DB_NONE) return;		if (calc->currentBinary == DB_PLUS || calc->currentBinary == DB_MINUS) {			tmp_result = DLPerc(calc->currentBinary,&calc->arg1,&calc->buffer,&tmp);			calc->buffer = tmp;			if (tmp_result) {				*next_state = DS_ERROR;			} else {				*next_state = DS_RESULT_STRONG;			}		} else {			goto here;		}	} else if (prev_state == DS_RESULT_GT_STRONG || prev_state == DS_RESULT_STRONG || prev_state == DS_RESULT_MU) {		if (calc->currentBinary == DB_MULT || calc->currentBinary == DB_DIV) {here:			if (calc->currentBinary == DB_MULT) {				if (prev_state == DS_BINOP)					calc->buffer = calc->arg1;				tmp_result = DLAuxPercMult(&calc->arg1,&calc->buffer,&tmp);				calc->buffer = tmp;				if (tmp_result) {					*next_state = DS_ERROR;				} else {					*next_state = DS_RESULT_STRONG;				}			} else if (calc->currentBinary == DB_DIV) {				if (prev_state == DS_BINOP)					fixed_to_dl("1000000000000",&calc->arg1);				tmp_result = DLAuxPercDiv(&calc->arg1,&calc->buffer,&tmp);				calc->buffer = tmp;				if (tmp_result) {					*next_state = DS_ERROR;				} else {					*next_state = DS_RESULT_STRONG;				}			}		} else return;	}	// Round buffer up	DLRound(calc,&calc->buffer);	if (*next_state != DS_ERROR) {		// Add buffer to gt!		tmp_result = DLAdd(&calc->gt,&calc->buffer,&tmp);		if (tmp_result) {			calc->buffer = tmp;			*next_state = DS_ERROR_GT;		} else {			calc->gt = tmp;		}	}}void DLBtnSq(DLCalc *calc, int prev_state, int *next_state) {	int tmp_result;	DLNumber tmp;	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP) return;	tmp_result = DLSqrt(&calc->buffer,&tmp);	if (tmp_result) {		*next_state = DS_ERROR;		return;	}	if (prev_state == DS_INPUT || prev_state == DS_INPUT_DECIMAL || prev_state == DS_RESULT_GT_WEAK || prev_state == DS_RESULT_WEAK) {		*next_state = DS_RESULT_WEAK;	} else if (prev_state == DS_INPUT_NOSWAP || prev_state == DS_INPUT_DECIMAL_NOSWAP || prev_state == DS_RESULT_WEAK_NOSWAP || prev_state == DS_RESULT_GT_WEAK_NOSWAP) {		*next_state = DS_RESULT_WEAK_NOSWAP;	} else if (prev_state == DS_RESULT_STRONG || prev_state == DS_RESULT_GT_STRONG || prev_state == DS_RESULT_MU) {		*next_state = DS_RESULT_WEAK_NOSWAP;	} else if (prev_state == DS_BINOP) {		calc->arg1 = calc->buffer;		*next_state = DS_RESULT_WEAK;	} else {		AppError("[SQRT BUTTON] I don't know how to switch from state %d.\n",prev_state);		*next_state = DS_ERROR;	}	calc->buffer = tmp;}void DLBtnSg(DLCalc *calc, int prev_state, int *next_state) {	int tmp_result;	DLNumber tmp;	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP) return;	calc->buffer.minus_mark = !(calc->buffer.minus_mark);}void DLBtnBinOp(DLCalc *calc, int op, int prev_state, int *next_state) {	int tmp_result;	DLNumber tmp;	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP) return;	if (prev_state == DS_INPUT || prev_state == DS_INPUT_DECIMAL || prev_state == DS_RESULT_WEAK		|| prev_state == DS_RESULT_GT_WEAK) {		// Evaluate the result first			tmp_result = DLAuxEval(calc);			if (tmp_result) {				*next_state = DS_ERROR;				return;			}	} else if (prev_state == DS_INPUT_NOSWAP || prev_state == DS_INPUT_DECIMAL_NOSWAP || prev_state == DS_RESULT_WEAK_NOSWAP || prev_state == DS_RESULT_GT_WEAK_NOSWAP) {		// NoSwap needs dropping the EX.		if (calc->fixMode == DF_ADD2 && (op == DB_PLUS || op == DB_MINUS) && prev_state == DS_INPUT_NOSWAP) {			DLNumber oneHundred = {0};			tmp = calc->arg1;			fixed_to_dl("10000000000",&oneHundred);			DLMul(&calc->buffer,&oneHundred,&tmp);			DLRound(calc,&tmp);			calc->buffer = tmp;		}	}	DLInitializeNumber(&calc->arg1); // Somehow the calculator always does this.	calc->currentBinary = op;	*next_state = DS_BINOP;}void DLBtnCe(DLCalc *calc, int prev_state, int *next_state) {	// Strong result, error -> C	// Weak result, binop, input -> CE	int tmp_result;	DLNumber tmp;	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP ||		prev_state == DS_RESULT_STRONG || prev_state == DS_RESULT_MU || prev_state == DS_RESULT_GT_STRONG) {			DLInitializeNumber(&calc->buffer);			DLInitializeNumber(&calc->arg1);			calc->currentBinary = DB_NONE;			*next_state = DS_RESULT_STRONG;	} else {		DLInitializeNumber(&calc->buffer);		if (prev_state != DS_BINOP) {			*next_state = DS_RESULT_WEAK;		} else {			*next_state = DS_BINOP;		}	}}void DLBtnAc(DLCalc *calc, int prev_state, int *next_state) {	// Reset but preserves ROUND / FIX	int roundConfig = calc->roundMode;	int fixConfig = calc->fixMode;	DLReset(calc);	calc->power = 1;	calc->roundMode = roundConfig;	calc->fixMode = fixConfig;	*next_state = calc->state;}void DLBtnEq(DLCalc *calc, int prev_state, int *next_state) {	DLNumber prev_arg1, prev_buffer, tmp;	int tmp_result;	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP) return;	prev_arg1 = calc->arg1;	prev_buffer = calc->buffer;	DLTrimNumber(&prev_buffer);	if (prev_state == DS_INPUT_NOSWAP || prev_state == DS_INPUT_DECIMAL_NOSWAP || prev_state == DS_RESULT_GT_WEAK_NOSWAP || prev_state == DS_RESULT_WEAK_NOSWAP || prev_state == DS_RESULT_STRONG || prev_state == DS_RESULT_GT_STRONG || prev_state == DS_RESULT_MU) {		// Swap the two args; do not swap it after calculation.		calc->buffer = prev_arg1;		calc->arg1 = prev_buffer;		tmp_result = DLAuxEval(calc);		// Refetch arg1 afterwards		calc->arg1 = prev_arg1;		DLRound(calc,&calc->buffer);		if (tmp_result) {			*next_state = DS_ERROR;			return;		}	} else {		tmp_result = DLAuxEval(calc);		DLRound(calc,&calc->buffer);		if (calc->currentBinary == DB_MULT)			calc->arg1 = prev_arg1;		else {			int op = calc->currentBinary;			if (calc->fixMode == DF_ADD2 && (op == DB_PLUS || op == DB_MINUS)) {				DLNumber oneHundred = {0};				tmp = calc->arg1;				fixed_to_dl("10000000000",&oneHundred);				DLMul(&prev_buffer,&oneHundred,&tmp);				DLRound(calc,&tmp);				prev_buffer = tmp;			}			calc->arg1 = prev_buffer;		}		if (tmp_result) {			*next_state = DS_ERROR;			return;		}	}	*next_state = DS_RESULT_STRONG;	tmp_result = DLAdd(&calc->gt, &calc->buffer, &tmp);	if (tmp_result) {		calc->buffer = tmp;		*next_state = DS_ERROR_GT;	}	calc->gt = tmp;}void DLBtnPd(DLCalc *calc, int prev_state, int *next_state) {	DLNumber tmp;	int tmp_result;	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP) return;	if (prev_state == DS_INPUT || prev_state == DS_INPUT_DECIMAL || prev_state == DS_BINOP || prev_state == DS_RESULT_WEAK || prev_state == DS_RESULT_GT_WEAK) {		*next_state = DS_INPUT_DECIMAL;	} else if (prev_state == DS_INPUT_NOSWAP || prev_state == DS_INPUT_DECIMAL_NOSWAP || prev_state == DS_RESULT_WEAK_NOSWAP || prev_state == DS_RESULT_GT_WEAK_NOSWAP		|| prev_state == DS_RESULT_STRONG || prev_state == DS_RESULT_GT_STRONG || prev_state == DS_RESULT_MU) {		*next_state = DS_INPUT_DECIMAL_NOSWAP;	}	if (prev_state == DS_BINOP) {		calc->arg1 = calc->buffer;		DLTrimNumber(&calc->arg1);	}	if (prev_state != DS_INPUT && prev_state != DS_INPUT_NOSWAP && prev_state != DS_INPUT_DECIMAL && prev_state != DS_INPUT_DECIMAL_NOSWAP) {		DLInitializeNumber(&calc->buffer);	}}void DLBtnNo(DLCalc *calc, int key_code, int prev_state, int *next_state) {	DLNumber tmp;	int tmp_result;	if (prev_state == DS_ERROR || prev_state == DS_ERROR_GT || prev_state == DS_ERROR_M || prev_state == DS_ERROR_INPUT || prev_state == DS_ERROR_INPUT_NOSWAP) return;	if (prev_state == DS_BINOP || prev_state == DS_RESULT_WEAK || prev_state == DS_RESULT_GT_WEAK) {		*next_state = DS_INPUT;	} else if (prev_state == DS_RESULT_WEAK_NOSWAP || prev_state == DS_RESULT_GT_WEAK_NOSWAP || prev_state == DS_RESULT_STRONG || prev_state == DS_RESULT_GT_STRONG || prev_state == DS_RESULT_MU) {		*next_state = DS_INPUT_NOSWAP;	}	if (prev_state == DS_BINOP) {		calc->arg1 = calc->buffer;		DLTrimNumber(&calc->arg1);	}	if (prev_state != DS_INPUT && prev_state != DS_INPUT_NOSWAP && prev_state != DS_INPUT_DECIMAL && prev_state != DS_INPUT_DECIMAL_NOSWAP) {		DLInitializeNumber(&calc->buffer);	}	tmp_result = DLShiftIn(&calc->buffer, key_code - DK_0 + '0', (prev_state == DS_INPUT_DECIMAL || prev_state == DS_INPUT_DECIMAL_NOSWAP));	if (tmp_result) {		if (prev_state == DS_INPUT) {			*next_state = DS_ERROR_INPUT;		} else if (prev_state == DS_INPUT_NOSWAP) {			*next_state = DS_ERROR_INPUT_NOSWAP;		} else			*next_state = DS_ERROR;	}}void DLBtn00(DLCalc *calc, int prev_state, int *next_state) {	DLBtnNo(calc,DK_0,prev_state,next_state);	DLBtnNo(calc,DK_0,prev_state,next_state);}void DLOPPushButton(DLCalc *calc, int btn) {	int prev_state = calc->state;	int next_state = prev_state;	int next_binop = calc->currentBinary;	DLNumber tmp;	int tmp_result;	if (!calc->power && btn != DK_AC) return;	switch (btn) {		case DK_EX:			DLBtnXchg(calc,prev_state,&next_state);			break;		case DK_MU:			DLBtnMu(calc,prev_state,&next_state);			break;		case DK_MC:			DLBtnMc(calc,prev_state,&next_state);			break;		case DK_MR:			DLBtnMr(calc,prev_state,&next_state);			break;		case DK_M_MINUS:			DLBtnMm(calc,prev_state,&next_state);			break;		case DK_M_PLUS:			DLBtnMp(calc,prev_state,&next_state);			break;		case DK_GT:			DLBtnGt(calc,prev_state,&next_state);			break;		case DK_BS:			DLBtnBs(calc,prev_state,&next_state);			break;		case DK_PERC:			DLBtnPc(calc,prev_state,&next_state);			break;		case DK_SQRT:			DLBtnSq(calc,prev_state,&next_state);			break;		case DK_SIGN:			DLBtnSg(calc,prev_state,&next_state);			break;		case DK_MULT:			DLBtnBinOp(calc,DB_MULT,prev_state,&next_state);			break;		case DK_DIV:			DLBtnBinOp(calc,DB_DIV,prev_state,&next_state);			break;		case DK_CE:			DLBtnCe(calc, prev_state, &next_state);			break;		case DK_PLUS:			DLBtnBinOp(calc,DB_PLUS,prev_state,&next_state);			break;		case DK_MINUS:			DLBtnBinOp(calc,DB_MINUS,prev_state,&next_state);			break;		case DK_AC:			DLBtnAc(calc,prev_state,&next_state);			break;		case DK_EQU:			DLBtnEq(calc,prev_state,&next_state);			break;		case DK_PERIOD:			DLBtnPd(calc,prev_state,&next_state);			break;		case DK_00:			DLBtn00(calc,prev_state,&next_state);			break;		case DK_0:		case DK_1:		case DK_2:		case DK_3:		case DK_4:		case DK_5:		case DK_6:		case DK_7:		case DK_8:		case DK_9:			DLBtnNo(calc,btn,prev_state,&next_state);			break;		case DK_OFF:			calc->power = 0;			break;		default:			AppError("Invalid button id: %d\n",btn);			break;	}	calc->state = next_state;}void DLOPSetRoundMode(DLCalc *calc, int mode) {	calc->roundMode = mode;}void DLOPSetFixMode(DLCalc *calc, int mode) {	calc->fixMode = mode;}void dl_round_to_specific_digit(int roundMode, DLNumber *x, int precision) {	int delta_precision;	DLNumber t = *x;	DLTrimNumber(&t);	delta_precision = t.period_pos - precision;	if (delta_precision < 0) {		// Pad zeroes		int abs = -delta_precision;		int ub;		int i;		// Figure out ub of the num		for (ub = 11; ub >= 0; ub--) {			if (t.digits[ub] != 0 && t.digits[ub] != '0') break;		}		if (ub == -1) {			DLInitializeNumber(&t);		}		i = 11;		if (ub + abs > 11) abs = 11 - ub;		while (i >= abs) {			t.digits[i] = t.digits[i-abs];			i--;		}		while (i >= 0) {			t.digits[i] = '0';			i--;		}		t.period_pos += abs;		*x = t;	} else if (delta_precision == 0) {		// Do nothing		return;	} else {		// Round		char xtra_digit = t.digits[delta_precision - 1];		int i;		// first shift left		for (i=0; i<12; i++) {			if (i+delta_precision <= 11)				t.digits[i] = t.digits[i+delta_precision];			else				t.digits[i] = 0;		}		t.period_pos -= delta_precision;		// Second round up / down		if (roundMode == DM_CEIL) {			if (xtra_digit >= '1')				t.digits[0]++;		} else if (roundMode == DM_ROUND) {			if (xtra_digit >= '5')				t.digits[0]++;		}		*x = t;	}}// This should be called only when calculator `needs' rounding.// Note that ADD2 works the same as 2 here -- you should div// by 100 manually in the logic code whenever needed.void DLRound(DLCalc *calc, DLNumber *x) {	switch (calc->fixMode) {	case DF_ADD2: case DF_2:		dl_round_to_specific_digit(calc->roundMode,x,2);		break;	case DF_4:		dl_round_to_specific_digit(calc->roundMode,x,4);		break;	case DF_3:		dl_round_to_specific_digit(calc->roundMode,x,3);		break;	case DF_0:		dl_round_to_specific_digit(calc->roundMode,x,0);		break;	case DF_F:		DLTrimNumber(x);		break;	}}void DLShiftOut(DLNumber *n) {	int i;	for (i=0; i<11; i++) {		n->digits[i] = n->digits[i+1];	}	n->digits[11] = 0;	if (n->period_pos > 0) n->period_pos--;	if (n->digits[0] == 0) {		n->minus_mark = 0;		n->digits[0] = '0';	}}int DLShiftIn(DLNumber *n, char fill, int shiftDot) {	int i;	if (DLIsZero(n)) {		DLInitializeNumber(n);		n->digits[0] = fill;		if (shiftDot) {			n->period_pos++;			n->digits[1] = '0';		}		return 0;	}	if (n->digits[11] != 0) {		if (shiftDot) return 0;		else return 1;	}	for (i=11; i>0; i--) {		n->digits[i] = n->digits[i-1];	}	n->digits[0] = fill;	if (shiftDot) n->period_pos++;	return 0;}